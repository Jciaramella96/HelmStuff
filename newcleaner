#!/usr/bin/env python3
import os
import argparse
import platform
import fnmatch


# Stubbed disk space check (replace with your method)
def check_disk_space(path: str):
    """Stub: replace with your disk space check method."""
    print(f"[INFO] Checking disk space for {path}... (stubbed)")
    # Example: shutil.disk_usage(path).free


def find_large_files(target_dir: str, size_threshold_mb: int):
    """Find files over the size_threshold_mb in the target_dir (no recursion)."""
    large_files = []
    size_threshold_bytes = size_threshold_mb * 1024 * 1024

    try:
        for name in os.listdir(target_dir):
            filepath = os.path.join(target_dir, name)
            if os.path.isfile(filepath):
                try:
                    size = os.path.getsize(filepath)
                    if size >= size_threshold_bytes:
                        large_files.append(filepath)
                except (FileNotFoundError, PermissionError):
                    continue
    except Exception as e:
        print(f"[ERROR] Could not list directory {target_dir}: {e}")

    return large_files


def load_approved_list(approved_file: str):
    """Load the list of pre-approved files/patterns for deletion (one per line)."""
    if not os.path.exists(approved_file):
        print(f"[WARN] Approved list file '{approved_file}' not found.")
        return set()
    with open(approved_file, "r") as f:
        return {line.strip() for line in f if line.strip()}


def filter_deletable_files(found_files, approved_patterns):
    """
    Return only files that are both large and match an approved pattern.
    - Supports exact filename matches (e.g., bigfile.log)
    - Supports wildcards (*.zip, backup_*.tar.gz)
    """
    deletable = []
    for f in found_files:
        filename = os.path.basename(f)
        for pattern in approved_patterns:
            if fnmatch.fnmatch(filename, pattern):  # handles both exact and wildcard
                deletable.append(f)
                break
    return deletable


def main():
    parser = argparse.ArgumentParser(description="Disk cleanup script")
    parser.add_argument("target_dir", help="Target directory to scan (non-recursive)")
    parser.add_argument("approved_list", help="File containing approved filenames or patterns (one per line)")
    parser.add_argument("--threshold", type=int, default=500,
                        help="File size threshold in MB (default: 500MB)")
    parser.add_argument("--delete", action="store_true", help="Actually delete files instead of dry run")
    args = parser.parse_args()

    system_type = platform.system()
    print(f"[INFO] Running on {system_type} system")

    # Step 1: Disk space check (stubbed)
    check_disk_space(args.target_dir)

    # Step 2: Find large files (top-level only)
    large_files = find_large_files(args.target_dir, args.threshold)
    print(f"[INFO] Found {len(large_files)} files >= {args.threshold}MB in {args.target_dir}")

    # Step 3: Load approved patterns
    approved_patterns = load_approved_list(args.approved_list)

    # Step 4: Match against approved patterns
    deletable_files = filter_deletable_files(large_files, approved_patterns)

    if not deletable_files:
        print("[INFO] No files eligible for deletion.")
        return

    print("\n[INFO] Files eligible for deletion:")
    for f in deletable_files:
        print(f"  {f}")

    if args.delete:
        print("\n[INFO] Deleting files...")
        for f in deletable_files:
            try:
                os.remove(f)
                print(f"[DELETED] {f}")
            except Exception as e:
                print(f"[ERROR] Could not delete {f}: {e}")
    else:
        print("\n[INFO] Dry run mode: No files deleted.")


if __name__ == "__main__":
    main()