#!/usr/bin/env python3
import os
import argparse
import platform
import fnmatch


def find_large_files(target_dir: str, size_threshold_mb: int):
    """Return absolute paths of files â‰¥ size_threshold_mb in target_dir (non-recursive)."""
    large_files = []
    size_threshold_bytes = size_threshold_mb * 1024 * 1024

    try:
        for name in os.listdir(target_dir):
            filepath = os.path.join(target_dir, name)
            if os.path.isfile(filepath):
                try:
                    size = os.path.getsize(filepath)
                    if size >= size_threshold_bytes:
                        large_files.append(os.path.abspath(filepath))
                except (FileNotFoundError, PermissionError):
                    continue
    except Exception as e:
        print(f"[ERROR] Could not list directory {target_dir}: {e}")

    return large_files


def load_approved_list(approved_file: str):
    """Load absolute paths or wildcard patterns from the approved list file (one per line)."""
    if not os.path.exists(approved_file):
        print(f"[WARN] Approved list file '{approved_file}' not found.")
        return set()
    with open(approved_file, "r") as f:
        return {line.strip() for line in f if line.strip() and not line.startswith("#")}


def filter_deletable_files(found_files, approved_patterns):
    """
    Return only files that match an approved absolute path or wildcard pattern.
    - Approved list can contain absolute paths (/target/dir/file.sql)
    - Or wildcards (/target/dir/*.zip, /target/dir/patch_dump_*)
    """
    deletable = []
    for f in found_files:
        for pattern in approved_patterns:
            if fnmatch.fnmatch(f, pattern):
                deletable.append(f)
                break
    return deletable


def main():
    parser = argparse.ArgumentParser(description="Disk cleanup script (absolute paths)")
    parser.add_argument("target_dir", help="Target directory to scan (non-recursive)")
    parser.add_argument("approved_list", help="File containing approved absolute paths or wildcard patterns")
    parser.add_argument("--threshold", type=int, default=500,
                        help="File size threshold in MB (default: 500MB)")
    parser.add_argument("--delete", action="store_true", help="Actually delete files instead of dry run")
    args = parser.parse_args()

    system_type = platform.system()
    print(f"[INFO] Running on {system_type} system")

    # Step 1: Find large files (array, not file)
    found_files = find_large_files(args.target_dir, args.threshold)
    print(f"[INFO] Found {len(found_files)} files >= {args.threshold}MB in {args.target_dir}")

    # Step 2: Load approved patterns
    approved_patterns = load_approved_list(args.approved_list)

    # Step 3: Match against approved list
    deletable_files = filter_deletable_files(found_files, approved_patterns)

    if not deletable_files:
        print("[INFO] No files eligible for deletion.")
        return

    print("\n[INFO] Files eligible for deletion:")
    for f in deletable_files:
        print(f"  {f}")

    if args.delete:
        print("\n[INFO] Deleting files...")
        for f in deletable_files:
            try:
                os.remove(f)
                print(f"[DELETED] {f}")
            except Exception as e:
                print(f"[ERROR] Could not delete {f}: {e}")
    else:
        print("\n[INFO] Dry run mode: No files deleted.")


if __name__ == "__main__":
    main()